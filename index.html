<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Digital Hand Skeleton</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        /* Custom neon glow effects */
        .neon-text {
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        }
        canvas {
            transform: scaleX(-1); /* Mirror effect for selfie mode */
        }
        /* Loading spinner */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #06b6d4;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-black text-white overflow-hidden w-full h-screen relative font-mono">

    <!-- Container for Video/Canvas -->
    <div class="relative w-full h-full flex justify-center items-center bg-gray-900">
        <!-- Hidden video element for raw input -->
        <video id="input_video" class="hidden" playsinline></video>
        
        <!-- Canvas for rendering output -->
        <canvas id="output_canvas" class="absolute top-0 left-0 w-full h-full object-cover"></canvas>
        
        <!-- Loading Overlay -->
        <div id="loading" class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/90 transition-opacity duration-500">
            <div class="loader mb-4"></div>
            <p class="text-cyan-400 tracking-widest text-sm animate-pulse">INITIALIZING NEURAL NET</p>
            <p class="text-gray-500 text-xs mt-2">Please allow camera access</p>
        </div>
    </div>

    <!-- UI Overlay -->
    <div class="absolute top-0 left-0 w-full p-4 z-10 flex justify-between items-start pointer-events-none">
        <div>
            <h1 class="text-cyan-400 font-bold text-lg neon-text tracking-tighter">HAND_SKELETON<span class="text-xs align-top opacity-70">v1.0</span></h1>
            <div class="flex items-center gap-2 mt-1">
                <div id="fps_meter" class="text-xs text-pink-500 font-bold">00 FPS</div>
                <div id="hand_count" class="text-xs text-emerald-400">WAITING...</div>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="absolute bottom-8 left-0 w-full flex justify-center gap-4 z-20 pointer-events-auto px-4">
        <button id="toggle_cam_btn" class="bg-gray-800/80 backdrop-blur border border-cyan-500/50 text-cyan-400 px-6 py-3 rounded-full text-sm font-bold active:scale-95 transition-transform shadow-[0_0_15px_rgba(6,182,212,0.3)] hover:bg-gray-700">
            TOGGLE FEED
        </button>
        <button id="toggle_conn_btn" class="bg-gray-800/80 backdrop-blur border border-pink-500/50 text-pink-400 px-6 py-3 rounded-full text-sm font-bold active:scale-95 transition-transform shadow-[0_0_15px_rgba(236,72,153,0.3)] hover:bg-gray-700">
            WIREFRAME
        </button>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingElement = document.getElementById('loading');
        const handCountElement = document.getElementById('hand_count');
        const fpsMeter = document.getElementById('fps_meter');
        
        const toggleCamBtn = document.getElementById('toggle_cam_btn');
        const toggleConnBtn = document.getElementById('toggle_conn_btn');

        // State
        let showCameraFeed = true;
        let showConnections = true;
        let lastFrameTime = 0;
        let isLoaded = false;

        // FPS Calculation
        function updateFPS() {
            const now = performance.now();
            const delta = now - lastFrameTime;
            if (delta >= 1000) { // Update every second roughly
                const fps = (1000 / (now - lastFrameTime)).toFixed(0); 
                // Simple easing for display
            }
            lastFrameTime = now;
        }

        function onResults(results) {
            if (!isLoaded) {
                isLoaded = true;
                loadingElement.classList.add('opacity-0');
                setTimeout(() => loadingElement.style.display = 'none', 500);
            }

            // Update stats
            const fps = Math.round(1000 / (performance.now() - lastFrameTime));
            lastFrameTime = performance.now();
            fpsMeter.innerText = `${fps} FPS`;

            // Adjust canvas size to match display size for crisp rendering
            canvasElement.width = canvasElement.clientWidth;
            canvasElement.height = canvasElement.clientHeight;

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // Draw Camera Feed
            if (showCameraFeed) {
                canvasCtx.drawImage(
                    results.image, 0, 0, canvasElement.width, canvasElement.height
                );
                // Darken the video slightly to make the skeleton pop
                canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
            } else {
                // Black background
                canvasCtx.fillStyle = '#050505';
                canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
                
                // Draw grid lines for "digital" feel in background
                drawGrid(canvasCtx, canvasElement.width, canvasElement.height);
            }

            // Handle detections
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handCountElement.innerText = `${results.multiHandLandmarks.length} HAND(S) DETECTED`;
                handCountElement.className = "text-xs text-emerald-400 font-bold neon-text";

                for (const landmarks of results.multiHandLandmarks) {
                    // Draw Connections (Bones)
                    if (showConnections) {
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
                            color: '#06b6d4', // Cyan
                            lineWidth: 4
                        });
                        // Add an inner glow line
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
                            color: '#ffffff',
                            lineWidth: 1
                        });
                    }

                    // Draw Landmarks (Joints)
                    drawLandmarks(canvasCtx, landmarks, {
                        color: '#ec4899', // Pink
                        fillColor: '#000000',
                        lineWidth: 2,
                        radius: 4
                    });
                }
            } else {
                handCountElement.innerText = "SEARCHING...";
                handCountElement.className = "text-xs text-yellow-500 animate-pulse";
            }
            canvasCtx.restore();
        }

        // Helper to draw a retro grid
        function drawGrid(ctx, w, h) {
            ctx.strokeStyle = 'rgba(6, 182, 212, 0.1)';
            ctx.lineWidth = 1;
            const step = 50;
            
            for (let x = 0; x < w; x += step) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = 0; y < h; y += step) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }
        }

        // Setup MediaPipe Hands
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1, // 0 is faster, 1 is more accurate. 1 works on most modern phones.
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Setup Camera
        // We use the Camera Utils library which handles the loop and frame timing
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });
        
        // Start Camera
        camera.start()
            .then(() => {
                console.log("Camera started");
            })
            .catch(err => {
                console.error("Camera error:", err);
                loadingElement.innerHTML = `<p class="text-red-500 text-center px-4">Error accessing camera.<br>Please ensure permissions are granted.</p>`;
            });

        // Button Listeners
        toggleCamBtn.addEventListener('click', () => {
            showCameraFeed = !showCameraFeed;
            toggleCamBtn.innerText = showCameraFeed ? "HIDE FEED" : "SHOW FEED";
            toggleCamBtn.classList.toggle('border-cyan-500/50');
            toggleCamBtn.classList.toggle('border-gray-600');
        });

        toggleConnBtn.addEventListener('click', () => {
            showConnections = !showConnections;
            // When we toggle connections off, we might just show dots, 
            // but effectively we might want to toggle styles. 
            // For now, let's make it toggle "Wireframe" vs "Points only" visually?
            // Or maybe just toggle the style. Let's keep it simple.
            // Actually, let's make this button toggle the "Digital Grid" vs "Plain Black" when feed is off?
            // No, user request was "digital skeleton".
            // Let's make this button toggle Skeleton Style.
            
            // Re-purposing to Toggle "Full Skeleton" vs "Joints Only"
            if (showConnections) {
                toggleConnBtn.innerText = "JOINTS ONLY";
                toggleConnBtn.classList.replace('text-pink-400', 'text-gray-400');
            } else {
                toggleConnBtn.innerText = "WIREFRAME";
                toggleConnBtn.classList.replace('text-gray-400', 'text-pink-400');
            }
        });

        // Handle Resize
        window.addEventListener('resize', () => {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        });

    </script>
</body>
</html>

